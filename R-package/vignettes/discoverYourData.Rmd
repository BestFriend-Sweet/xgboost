---
title: "Understand your dataset with XGBoost"
date: "Wednesday, January 28, 2015"
output:  html_document
---

The purpose of this Vignette is to show you how to use **Xgboost** to discover and better understand your own dataset.

You may know Xgboost as a state of the art tool to build some kind of Machine learning models. It has been used to win several [Kaggle](http://www.kaggle.com/) competition. 

During these competition, the purpose is to make prediction. This Vignette is not about showing you how to predict anything. The purpose of this document is to explain *how to use **Xgboost** to understand the link between the features of your data and an outcome*.

For the purpose of this tutorial we will first load the required packages.

Note that **VCD** is used for one of its embedded dataset only.

```{r libLoading, results='hold', message=F, warning=F}
require(xgboost)
require(Matrix)
require(data.table)
if (!require(vcd)) install.packages('vcd') 
```

According to its documentation, **Xgboost** works only on *numbers*.

Sometimes the dataset we have to work on have *categorical* data. 

A *categorical* variable is one which have a fixed number of different values. By exemple, if for each observation a variable called *Colour* can have only *red*, *blue* or *green* as value, it is a *categorical* variable.

In **R**, *categorical* variable is called *Factor*.
Type `?factor` in console for more information.

In this demo we will see how to transform a dense dataframe with *categorical* variables to a sparse matrix before analyzing it in Xgboost.
The method we are going to see is usually called "one hot encoding".

#load Arthritis dataset in memory.
```{r, results='hide'}
data(Arthritis)
```
create a copy of the dataset with data.table package (data.table is 100% compliant with R dataframe but its syntax is a lot more consistent and its performance are really good).
```{r}
df <- data.table(Arthritis, keep.rownames = F)
```

Let's have a look to the data.table
```{r}
print(df[1:10])
```


2 columns have factor type, one has ordinal type (ordinal variable is a categorical variable with values wich can be ordered, here: None > Some > Marked).
```{r}
str(df)
```


Let's add some new categorical features to see if it helps. Of course these feature are highly correlated to the Age feature. Usually it's not a good thing in ML, but Tree algorithms (including boosted trees) are able to select the best features, even in case of highly correlated features.

For the first feature we create groups of age by rounding the real age. Note that we transform it to factor (categorical data) so the algorithm treat them as independant values.
```{r}
df[,AgeDiscret:= as.factor(round(Age/10,0))][1:10]
```


Here is an even stronger simplification of the real age with an arbitrary split at 30 years old. I choose this value based on nothing. We will see later if simplifying the information based on arbitrary values is a good strategy (I am sure you already have an idea of how well it will work!).
```{r}
df[,AgeCat:= as.factor(ifelse(Age > 30, "Old", "Young"))][1:10]
```


We remove ID as there is nothing to learn from this feature (it will just add some noise as the dataset is small).
```{r, results='hide'}
df[,ID:=NULL]
```


List the different values for the column Treatment: Placebo, Treated.
```{r}
print(levels(df[,Treatment]))
```


Next step, we will transform the categorical data to dummy variables.
This method is also called one hot encoding.
The purpose is to transform each value of each categorical feature in one binary feature.
#
Let's take, the column Treatment will be replaced by two columns, Placebo, and Treated. Each of them will be binary. For example an observation which had the value Placebo in column Treatment before the transformation will have, after the transformation, the value 1 in the new column Placebo and the value 0 in the new column  Treated.
#
Formulae Improved~.-1 used below means transform all categorical features but column Improved to binary values.
Column Improved is excluded because it will be our output column, the one we want to predict.
```{r, warning=FALSE,message=FALSE}
sparse_matrix <- sparse.model.matrix(Improved~.-1, data = df)
print(sparse_matrix[1:10,])

```

Create the output vector (not sparse)
1. Set, for all rows, field in Y column to 0; 
2. set Y to 1 when Improved == Marked; 
3. Return Y column
```{r}
output_vector = df[,Y:=0][Improved == "Marked",Y:=1][,Y]
```


Following is the same process as other demo
```{r}
bst <- xgboost(data = sparse_matrix, label = output_vector, max.depth = 9,
               eta = 1, nround = 10,objective = "binary:logistic")
xgb.dump(bst, 'xgb.model.dump', with.stats = T)

```

sparse_matrix@Dimnames[[2]] represents the column names of the sparse matrix.
```{r}
importance <- xgb.importance(sparse_matrix@Dimnames[[2]], 'xgb.model.dump')
print(importance)

```

According to the matrix below, the most important feature in this dataset to predict if the treatment will work is the Age. The second most important feature is having received a placebo or not. The sex is third. Then we see our generated features (AgeDiscret). We can see that their contribution is very low (Gain column).

Does these results make sense?
Let's check some Chi2 between each of these features and the outcome.

```{r}
print(chisq.test(df$Age, df$Y))
```

Pearson correlation between Age and illness disapearing is 35

```{r}
print(chisq.test(df$AgeDiscret, df$Y))
```

Our first simplification of Age gives a Pearson correlation of 8.

```{r}
print(chisq.test(df$AgeCat, df$Y))
xgb.plot.importance(importance_matrix = importance)
```

The perfectly random split I did between young and old at 30 years old have a low correlation of 2. It's a result we may expect as may be in my mind > 30 years is being old (I am 32 and starting feeling old, this may explain that), but  for the illness we are studying, the age to be vulnerable is not the same. Don't let your "gut" lower the quality of your model. In *data science* expression, there is the word *science* :-)

As you can see, in general destroying information by simplying it won't improve your model. Chi2 just demonstrates that. But in more complex cases, creating a new feature based on existing one which makes link with the outcome more obvious may help the algorithm and improve the model. The case studied here is not enough complex to show that. Check Kaggle forum for some challenging datasets.
However it's almost always worse when you add some arbitrary rules.
Moreover, you can notice that even if we have added some not useful new features highly correlated with other features, the boosting tree algorithm have been able to choose the best one, which in this case is the Age. Linear model may not be that strong in these scenario.

```{r}
xgb.plot.tree(sparse_matrix@Dimnames[[2]], model = bst, n_first_tree = 1)
```


